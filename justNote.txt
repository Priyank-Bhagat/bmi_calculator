--------------------vid 123------------------------------------


If some code/Widget started repeating many times then it's better to Make Class of that repeated widget.

steps:-

1> move cursor to that widget. and then click on FLUTTER OUTLINE.
2> right click on that widget that shown in hirarchy of FLUTTER OUTLINE.
3> Select option "Extract Widget"
and that's it just delete repeated code and just call that class.
4> you can add Constructor if you want to change some fields of code.
Ex:-

class CustomCard extends StatelessWidget {

[STAR*]  const CustomCard({super.key, required this.colour});

[STAR*]  final Color colour;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(10),
        color: colour,
      ),
      margin: const EdgeInsets.all(9),
    );
  }
}



--------------------vid 124------------------------------------

Mutable means Changeable.
Unmutable means Unchangeable.


-> Final and Const are both Unmutable.

-> Const = const will only initialize at Compiling time. It can't be assign value after code complied or in middle of running.

-> Final = Final can be initialize only one time. We can assign assign value to Final in the middle of running code. 
   [when we use final in Class. when the new value assign to Final variable at that time old widget/class will be destoryed 
     and new widget/class will replace it. But we can't see that process.]



--------------------vid 127------------------------------------


enum = enumeration = value typed in WORDS.

syntex => enum EnumName {vale, value}

[when we try to select something we assume eg. 1=male 2=female , but here we can directly assign word value using enum don't need to use number.]
exmaple => enum Gender {male , female}

        => access -> Gender.male / Gender.female


--------------------vid 128------------------------------------
 

ternary operator



--------------------vid 129------------------------------------


we can also pass function if we extracted widget.

ex..


class CustomCard extends StatelessWidget {
  const CustomCard({super.key, required this.colour, this.cardChild,  this.tapDetec});

       final Color colour;
       final Widget? cardChild;
->***  final Function()?  tapDetec;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
->***      onTap: tapDetec,
           child: Container(
                             decoration: BoxDecoration(
                                                        borderRadius: BorderRadius.circular(10),
                                                          color: colour,
                                                          ),
        margin: const EdgeInsets.all(9),
        child: cardChild,
      ),
    );
  }
}


--------------------vid 130------------------------------------

Slider widget

Slider(
                    value: height.toDouble(),
                    onChanged: (newValue) {
                      setState(() {                               // it's important to use set State here other wise slider will not get updated on screen.
                        height = newValue.round();
                        print(height);
                      });
                    },
                    min: 110,
                    max: 220,
                    activeColor: Color(0xffEB1555),
                    inactiveColor: Color(0xff8D8E98),
                  )




-----------------Vid 131--------------------------------------------------

if we want to customize more of Slider then we have to wrap Slide widget with SliderTheme Widget.



SliderTheme(
                    data: SliderTheme.of(context).copyWith(   // here We used [.of(context)] it's used to copy widget from current state and then we can change it using [.copywith()] we don't have to specify all the values.
                      activeTrackColor:Colors.white ,
                      inactiveTrackColor: Color(0xff8D8E98),
                      thumbColor: Color(0xffEb1555),
                    ),
                    child: Slider(
                      value: height.toDouble(),





-----------------Vid 132--------------------------------------------------



Composition  = make complex thing with basic things.

inheritance  = copy prebuild and just change some fields.


Flutter widget build on composition. some small widget are used to build complex widget like LEGO.

steps :-
1> look into widget. hold 'ctrl' and click on widget.
2> and see fields and mainly "result" field.
3> now we can use the same widget to build tha Complex widget with scratch.
4> make Stateless widget and name it. and in return add that basic widget.

conclusion -> we are not limited with flutter pre-defined custom fields. we can also build our own widget with scratch.


